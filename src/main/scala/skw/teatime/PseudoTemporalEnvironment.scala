package skw.teatime

// Pseudo-temporal environments are then used to provide pseudo-times for version 
// references used implicitly in comnputations. There are two ways to get pseudo-times 
// from a pseudo-temnporal environmnent. If one is needed for a version_ref$lookup operation,
// there is no need to get one that differs from the one last used for a version_refSdefine
// operation. If one is needed for a versIon_ref$defjne operation, it must bestrictly later
// than any one used previously to define a version of the object. We ensure that by saying
// that the pseudo-time used for a version_refSdefine operation is later than the pseudo-time
// used for the last version_refSdefme or version_refSlookup in the same pseudo-temporal environment.
//
// Two operations are thus used to select the next pseudo-time to be used in a program.
// The first, pteScurrent is used only for desugaring reads into version_ref5lookup operations,
// and the second, pteSnext is used only for desugaring updates into version_ref$define operations.
case class PseudoTemporalEnvironment(start: Pseudotime, end: Pseudotime) {
  val Epsilon: Pseudotime = Pseudotime(0.0001)
  var lastSubrangeEnd: Pseudotime = start

  def ~>(other: PseudoTemporalEnvironment): Boolean = 
    this.end < other.start

  // The pseudo-temporal environment pte2 is a subrange of this pte. 
  // It is guaranteed that the result of two separate invocations of pteStransaction
  // on the same pte will be two pteâ€™s x and y such that x~>y or y~>x. That is, 
  // x and y are non-overlapping subranges. Further , after executing w: pteStransaction(z),
  // w is a subset of z. pte$transaction can be applied repeatedly. in order to generate 
  // subranges of subranges
  def transaction(): PseudoTemporalEnvironment = {
    val subrangeEnd = (end + lastSubrangeEnd) / 2
    val subrange = PseudoTemporalEnvironment(lastSubrangeEnd + Epsilon, subrangeEnd)
    this.lastSubrangeEnd = subrangeEnd
    subrange
  }

  // If X is the set of pseudo-times returned by pteSnext(y) operations or contained in 
  // pseudo-temporal environments generated by pte$transaction(y) operations executed
  // before a:=pte$current(y) is executed , then for all xcX , x~>a.
  // ie. Any times subsequently generated will be AFTER the current returned by this method.
  def current(): Pseudotime =
    lastSubrangeEnd

  // If X is the set of pseudo-times returned by pteSnext(y) operations or contained in
  // pseudo-temporal environments generated by pteStransaction(y) operations executed
  // before a:=pteSnext(y), then for all xcX, a~>x.
  def next(): Pseudotime = {
    val subrangeEnd = (end + lastSubrangeEnd) / 2
    this.lastSubrangeEnd = subrangeEnd
    this.lastSubrangeEnd
  }
}

object PseudoTemporalEnvironment {
  // def in(???)
}